#!raku

use experimental :cached;

my @pebbles = $*IN.slurp.split(" ")>>.Int;

sub number-of-digits(Int $n) {
    # HOW TO DO THIS WITH MATH??!?!??!
    # log10(1000) returns 2.9999999999999996 in raku
    $n.Str.chars
}

# based on Lantern Fish solution https://github.com/mcmillhj/aoc/blob/main/2021/06/lanternfish.p6
sub count-pebbles(Int $pebble-state, Int $blinks) is cached {
    my $number-of-digits = number-of-digits($pebble-state);

    # once there are no more blinks remaining, each remaining pebble counts as 1
    return 1 
        if $blinks == 0;

    # if the current pebble state is 0, change the value to 1 and count the number of pebbles created by a pebble with value 1
    return count-pebbles(1, $blinks - 1)
        if $pebble-state == 0;

    # if the current pebble state has an even number of digits, split this pebble into two new pebbles and count the number of pebbles created from blinking at the two new pebbles
    if $number-of-digits %% 2 {
        my $factor = (10 ** ($number-of-digits / 2)).Int;
        return count-pebbles($pebble-state div $factor, $blinks - 1) + count-pebbles($pebble-state mod $factor, $blinks - 1);
    }

    # if no other rules apply, multiply the current pebble state by 2024 then count the number of pebbles generated by blinking at the new pebble
    return count-pebbles($pebble-state * 2024, $blinks - 1);

} 

say [+] @pebbles.map: -> $p { count-pebbles($p, 25) };
say [+] @pebbles.map: -> $p { count-pebbles($p, 75) };
